/* tslint:disable */
/* eslint-disable */
/**
 * NestJS/NextJS Template
 * API for NestJS/NextJS Template
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from '../common';
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  RequestArgs,
  BaseAPI,
  RequiredError,
} from '../base';
// @ts-ignore
import { AccessTokenDTO } from '../models';
// @ts-ignore
import { CategoryDTO } from '../models';
// @ts-ignore
import { CreateJobApplicationDTO } from '../models';
// @ts-ignore
import { CreateJobOpeningDTO } from '../models';
// @ts-ignore
import { CreateNotificationDTO } from '../models';
// @ts-ignore
import { FreelancerDTO } from '../models';
// @ts-ignore
import { JobApplicationDTO } from '../models';
// @ts-ignore
import { JobOpeningDTO } from '../models';
// @ts-ignore
import { LoginResponseDTO } from '../models';
// @ts-ignore
import { LoginUserDTO } from '../models';
// @ts-ignore
import { Message } from '../models';
// @ts-ignore
import { NotificationDTO } from '../models';
// @ts-ignore
import { NotificationsDTO } from '../models';
// @ts-ignore
import { RefreshTokenDTO } from '../models';
// @ts-ignore
import { RegisterUserDTO } from '../models';
// @ts-ignore
import { Room } from '../models';
// @ts-ignore
import { RoomDTO } from '../models';
// @ts-ignore
import { SendMessageDTO } from '../models';
// @ts-ignore
import { UserDTO } from '../models';
/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {JobOpeningDTO} jobOpeningDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    archiveJobOpening: async (
      jobOpeningDTO: JobOpeningDTO,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'jobOpeningDTO' is not null or undefined
      assertParamExists('archiveJobOpening', 'jobOpeningDTO', jobOpeningDTO);
      const localVarPath = `/api/v1/job-opening/archive`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        jobOpeningDTO,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {CreateJobApplicationDTO} createJobApplicationDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createJobApplication: async (
      createJobApplicationDTO: CreateJobApplicationDTO,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'createJobApplicationDTO' is not null or undefined
      assertParamExists(
        'createJobApplication',
        'createJobApplicationDTO',
        createJobApplicationDTO
      );
      const localVarPath = `/api/v1/job-application`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createJobApplicationDTO,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {CreateJobOpeningDTO} createJobOpeningDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createJobOpening: async (
      createJobOpeningDTO: CreateJobOpeningDTO,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'createJobOpeningDTO' is not null or undefined
      assertParamExists(
        'createJobOpening',
        'createJobOpeningDTO',
        createJobOpeningDTO
      );
      const localVarPath = `/api/v1/job-opening`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createJobOpeningDTO,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {CreateNotificationDTO} createNotificationDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createNotification: async (
      createNotificationDTO: CreateNotificationDTO,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'createNotificationDTO' is not null or undefined
      assertParamExists(
        'createNotification',
        'createNotificationDTO',
        createNotificationDTO
      );
      const localVarPath = `/api/v1/notification`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createNotificationDTO,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} jobApplicationId
     * @param {FreelancerDTO} freelancerDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteJobApplication: async (
      jobApplicationId: string,
      freelancerDTO: FreelancerDTO,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'jobApplicationId' is not null or undefined
      assertParamExists(
        'deleteJobApplication',
        'jobApplicationId',
        jobApplicationId
      );
      // verify required parameter 'freelancerDTO' is not null or undefined
      assertParamExists('deleteJobApplication', 'freelancerDTO', freelancerDTO);
      const localVarPath = `/api/v1/job-application/{jobApplicationId}`.replace(
        `{${'jobApplicationId'}}`,
        encodeURIComponent(String(jobApplicationId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        freelancerDTO,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {JobOpeningDTO} jobOpeningDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteJobOpening: async (
      jobOpeningDTO: JobOpeningDTO,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'jobOpeningDTO' is not null or undefined
      assertParamExists('deleteJobOpening', 'jobOpeningDTO', jobOpeningDTO);
      const localVarPath = `/api/v1/job-opening`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        jobOpeningDTO,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllCategories: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/category`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllJobOpenings: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/job-opening`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} jobOpeningId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getApplicants: async (
      jobOpeningId: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'jobOpeningId' is not null or undefined
      assertParamExists('getApplicants', 'jobOpeningId', jobOpeningId);
      const localVarPath =
        `/api/v1/job-opening/{jobOpeningId}/applicants`.replace(
          `{${'jobOpeningId'}}`,
          encodeURIComponent(String(jobOpeningId))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getHello: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/v1`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} freelancerId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getJobApplicationsByFreelancer: async (
      freelancerId: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'freelancerId' is not null or undefined
      assertParamExists(
        'getJobApplicationsByFreelancer',
        'freelancerId',
        freelancerId
      );
      const localVarPath =
        `/api/v1/job-application/freelancer/{freelancerId}`.replace(
          `{${'freelancerId'}}`,
          encodeURIComponent(String(freelancerId))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} jobOpeningId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getJobApplicationsByJobOpening: async (
      jobOpeningId: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'jobOpeningId' is not null or undefined
      assertParamExists(
        'getJobApplicationsByJobOpening',
        'jobOpeningId',
        jobOpeningId
      );
      const localVarPath =
        `/api/v1/job-application/job-opening/{jobOpeningId}`.replace(
          `{${'jobOpeningId'}}`,
          encodeURIComponent(String(jobOpeningId))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} employerId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getJobOpeningsByEmployer: async (
      employerId: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'employerId' is not null or undefined
      assertParamExists('getJobOpeningsByEmployer', 'employerId', employerId);
      const localVarPath = `/api/v1/job-opening/employer/{employerId}`.replace(
        `{${'employerId'}}`,
        encodeURIComponent(String(employerId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNotifications: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/notification`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRoomsOfUser: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/chat/rooms`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsers: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/user`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    joinRoom: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/chat/rooms`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {LoginUserDTO} loginUserDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logIn: async (
      loginUserDTO: LoginUserDTO,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'loginUserDTO' is not null or undefined
      assertParamExists('logIn', 'loginUserDTO', loginUserDTO);
      const localVarPath = `/api/v1/auth/login`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        loginUserDTO,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {UserDTO} userDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logOut: async (
      userDTO: UserDTO,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userDTO' is not null or undefined
      assertParamExists('logOut', 'userDTO', userDTO);
      const localVarPath = `/api/v1/auth/logout`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        userDTO,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {Array<string>} requestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    markMessageAsSeen: async (
      requestBody: Array<string>,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'requestBody' is not null or undefined
      assertParamExists('markMessageAsSeen', 'requestBody', requestBody);
      const localVarPath = `/api/v1/chat/messages`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestBody,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {NotificationDTO} notificationDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    markNotifcationAsRead: async (
      notificationDTO: NotificationDTO,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'notificationDTO' is not null or undefined
      assertParamExists(
        'markNotifcationAsRead',
        'notificationDTO',
        notificationDTO
      );
      const localVarPath = `/api/v1/notification`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        notificationDTO,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {RefreshTokenDTO} refreshTokenDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refresh: async (
      refreshTokenDTO: RefreshTokenDTO,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'refreshTokenDTO' is not null or undefined
      assertParamExists('refresh', 'refreshTokenDTO', refreshTokenDTO);
      const localVarPath = `/api/v1/auth/refresh`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        refreshTokenDTO,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {RegisterUserDTO} registerUserDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    register: async (
      registerUserDTO: RegisterUserDTO,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'registerUserDTO' is not null or undefined
      assertParamExists('register', 'registerUserDTO', registerUserDTO);
      const localVarPath = `/api/v1/auth/register`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        registerUserDTO,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {SendMessageDTO} sendMessageDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendMessage: async (
      sendMessageDTO: SendMessageDTO,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sendMessageDTO' is not null or undefined
      assertParamExists('sendMessage', 'sendMessageDTO', sendMessageDTO);
      const localVarPath = `/api/v1/chat/messages`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        sendMessageDTO,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {JobOpeningDTO} jobOpeningDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async archiveJobOpening(
      jobOpeningDTO: JobOpeningDTO,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.archiveJobOpening(
          jobOpeningDTO,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {CreateJobApplicationDTO} createJobApplicationDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createJobApplication(
      createJobApplicationDTO: CreateJobApplicationDTO,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createJobApplication(
          createJobApplicationDTO,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {CreateJobOpeningDTO} createJobOpeningDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createJobOpening(
      createJobOpeningDTO: CreateJobOpeningDTO,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobOpeningDTO>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createJobOpening(
          createJobOpeningDTO,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {CreateNotificationDTO} createNotificationDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createNotification(
      createNotificationDTO: CreateNotificationDTO,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<NotificationDTO>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createNotification(
          createNotificationDTO,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} jobApplicationId
     * @param {FreelancerDTO} freelancerDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteJobApplication(
      jobApplicationId: string,
      freelancerDTO: FreelancerDTO,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteJobApplication(
          jobApplicationId,
          freelancerDTO,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {JobOpeningDTO} jobOpeningDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteJobOpening(
      jobOpeningDTO: JobOpeningDTO,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteJobOpening(
          jobOpeningDTO,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAllCategories(
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<CategoryDTO>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getAllCategories(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAllJobOpenings(
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<JobOpeningDTO>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getAllJobOpenings(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} jobOpeningId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getApplicants(
      jobOpeningId: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserDTO>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getApplicants(
        jobOpeningId,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getHello(
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getHello(
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} freelancerId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getJobApplicationsByFreelancer(
      freelancerId: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<JobApplicationDTO>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getJobApplicationsByFreelancer(
          freelancerId,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} jobOpeningId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getJobApplicationsByJobOpening(
      jobOpeningId: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<JobApplicationDTO>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getJobApplicationsByJobOpening(
          jobOpeningId,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} employerId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getJobOpeningsByEmployer(
      employerId: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<JobOpeningDTO>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getJobOpeningsByEmployer(
          employerId,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getNotifications(
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<NotificationsDTO>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getNotifications(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRoomsOfUser(
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RoomDTO>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getRoomsOfUser(
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUsers(
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserDTO>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers(
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async joinRoom(
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Room>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.joinRoom(
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {LoginUserDTO} loginUserDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async logIn(
      loginUserDTO: LoginUserDTO,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<LoginResponseDTO>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.logIn(
        loginUserDTO,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {UserDTO} userDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async logOut(
      userDTO: UserDTO,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.logOut(
        userDTO,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {Array<string>} requestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async markMessageAsSeen(
      requestBody: Array<string>,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.markMessageAsSeen(requestBody, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {NotificationDTO} notificationDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async markNotifcationAsRead(
      notificationDTO: NotificationDTO,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.markNotifcationAsRead(
          notificationDTO,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {RefreshTokenDTO} refreshTokenDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async refresh(
      refreshTokenDTO: RefreshTokenDTO,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessTokenDTO>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.refresh(
        refreshTokenDTO,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {RegisterUserDTO} registerUserDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async register(
      registerUserDTO: RegisterUserDTO,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<LoginResponseDTO>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.register(
        registerUserDTO,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {SendMessageDTO} sendMessageDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sendMessage(
      sendMessageDTO: SendMessageDTO,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.sendMessage(
        sendMessageDTO,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = DefaultApiFp(configuration);
  return {
    /**
     *
     * @param {JobOpeningDTO} jobOpeningDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    archiveJobOpening(
      jobOpeningDTO: JobOpeningDTO,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .archiveJobOpening(jobOpeningDTO, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {CreateJobApplicationDTO} createJobApplicationDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createJobApplication(
      createJobApplicationDTO: CreateJobApplicationDTO,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .createJobApplication(createJobApplicationDTO, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {CreateJobOpeningDTO} createJobOpeningDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createJobOpening(
      createJobOpeningDTO: CreateJobOpeningDTO,
      options?: any
    ): AxiosPromise<JobOpeningDTO> {
      return localVarFp
        .createJobOpening(createJobOpeningDTO, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {CreateNotificationDTO} createNotificationDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createNotification(
      createNotificationDTO: CreateNotificationDTO,
      options?: any
    ): AxiosPromise<NotificationDTO> {
      return localVarFp
        .createNotification(createNotificationDTO, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} jobApplicationId
     * @param {FreelancerDTO} freelancerDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteJobApplication(
      jobApplicationId: string,
      freelancerDTO: FreelancerDTO,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .deleteJobApplication(jobApplicationId, freelancerDTO, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {JobOpeningDTO} jobOpeningDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteJobOpening(
      jobOpeningDTO: JobOpeningDTO,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .deleteJobOpening(jobOpeningDTO, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllCategories(options?: any): AxiosPromise<Array<CategoryDTO>> {
      return localVarFp
        .getAllCategories(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllJobOpenings(options?: any): AxiosPromise<Array<JobOpeningDTO>> {
      return localVarFp
        .getAllJobOpenings(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} jobOpeningId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getApplicants(
      jobOpeningId: string,
      options?: any
    ): AxiosPromise<Array<UserDTO>> {
      return localVarFp
        .getApplicants(jobOpeningId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getHello(options?: any): AxiosPromise<string> {
      return localVarFp
        .getHello(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} freelancerId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getJobApplicationsByFreelancer(
      freelancerId: string,
      options?: any
    ): AxiosPromise<Array<JobApplicationDTO>> {
      return localVarFp
        .getJobApplicationsByFreelancer(freelancerId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} jobOpeningId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getJobApplicationsByJobOpening(
      jobOpeningId: string,
      options?: any
    ): AxiosPromise<Array<JobApplicationDTO>> {
      return localVarFp
        .getJobApplicationsByJobOpening(jobOpeningId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} employerId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getJobOpeningsByEmployer(
      employerId: string,
      options?: any
    ): AxiosPromise<Array<JobOpeningDTO>> {
      return localVarFp
        .getJobOpeningsByEmployer(employerId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNotifications(options?: any): AxiosPromise<NotificationsDTO> {
      return localVarFp
        .getNotifications(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRoomsOfUser(options?: any): AxiosPromise<Array<RoomDTO>> {
      return localVarFp
        .getRoomsOfUser(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsers(options?: any): AxiosPromise<Array<UserDTO>> {
      return localVarFp
        .getUsers(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    joinRoom(options?: any): AxiosPromise<Room> {
      return localVarFp
        .joinRoom(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {LoginUserDTO} loginUserDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logIn(
      loginUserDTO: LoginUserDTO,
      options?: any
    ): AxiosPromise<LoginResponseDTO> {
      return localVarFp
        .logIn(loginUserDTO, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {UserDTO} userDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logOut(userDTO: UserDTO, options?: any): AxiosPromise<void> {
      return localVarFp
        .logOut(userDTO, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {Array<string>} requestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    markMessageAsSeen(
      requestBody: Array<string>,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .markMessageAsSeen(requestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {NotificationDTO} notificationDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    markNotifcationAsRead(
      notificationDTO: NotificationDTO,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .markNotifcationAsRead(notificationDTO, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {RefreshTokenDTO} refreshTokenDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refresh(
      refreshTokenDTO: RefreshTokenDTO,
      options?: any
    ): AxiosPromise<AccessTokenDTO> {
      return localVarFp
        .refresh(refreshTokenDTO, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {RegisterUserDTO} registerUserDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    register(
      registerUserDTO: RegisterUserDTO,
      options?: any
    ): AxiosPromise<LoginResponseDTO> {
      return localVarFp
        .register(registerUserDTO, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {SendMessageDTO} sendMessageDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendMessage(
      sendMessageDTO: SendMessageDTO,
      options?: any
    ): AxiosPromise<Message> {
      return localVarFp
        .sendMessage(sendMessageDTO, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
  /**
   *
   * @param {JobOpeningDTO} jobOpeningDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public archiveJobOpening(jobOpeningDTO: JobOpeningDTO, options?: any) {
    return DefaultApiFp(this.configuration)
      .archiveJobOpening(jobOpeningDTO, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {CreateJobApplicationDTO} createJobApplicationDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public createJobApplication(
    createJobApplicationDTO: CreateJobApplicationDTO,
    options?: any
  ) {
    return DefaultApiFp(this.configuration)
      .createJobApplication(createJobApplicationDTO, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {CreateJobOpeningDTO} createJobOpeningDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public createJobOpening(
    createJobOpeningDTO: CreateJobOpeningDTO,
    options?: any
  ) {
    return DefaultApiFp(this.configuration)
      .createJobOpening(createJobOpeningDTO, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {CreateNotificationDTO} createNotificationDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public createNotification(
    createNotificationDTO: CreateNotificationDTO,
    options?: any
  ) {
    return DefaultApiFp(this.configuration)
      .createNotification(createNotificationDTO, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} jobApplicationId
   * @param {FreelancerDTO} freelancerDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public deleteJobApplication(
    jobApplicationId: string,
    freelancerDTO: FreelancerDTO,
    options?: any
  ) {
    return DefaultApiFp(this.configuration)
      .deleteJobApplication(jobApplicationId, freelancerDTO, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {JobOpeningDTO} jobOpeningDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public deleteJobOpening(jobOpeningDTO: JobOpeningDTO, options?: any) {
    return DefaultApiFp(this.configuration)
      .deleteJobOpening(jobOpeningDTO, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getAllCategories(options?: any) {
    return DefaultApiFp(this.configuration)
      .getAllCategories(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getAllJobOpenings(options?: any) {
    return DefaultApiFp(this.configuration)
      .getAllJobOpenings(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} jobOpeningId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getApplicants(jobOpeningId: string, options?: any) {
    return DefaultApiFp(this.configuration)
      .getApplicants(jobOpeningId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getHello(options?: any) {
    return DefaultApiFp(this.configuration)
      .getHello(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} freelancerId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getJobApplicationsByFreelancer(freelancerId: string, options?: any) {
    return DefaultApiFp(this.configuration)
      .getJobApplicationsByFreelancer(freelancerId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} jobOpeningId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getJobApplicationsByJobOpening(jobOpeningId: string, options?: any) {
    return DefaultApiFp(this.configuration)
      .getJobApplicationsByJobOpening(jobOpeningId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} employerId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getJobOpeningsByEmployer(employerId: string, options?: any) {
    return DefaultApiFp(this.configuration)
      .getJobOpeningsByEmployer(employerId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getNotifications(options?: any) {
    return DefaultApiFp(this.configuration)
      .getNotifications(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getRoomsOfUser(options?: any) {
    return DefaultApiFp(this.configuration)
      .getRoomsOfUser(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getUsers(options?: any) {
    return DefaultApiFp(this.configuration)
      .getUsers(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public joinRoom(options?: any) {
    return DefaultApiFp(this.configuration)
      .joinRoom(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {LoginUserDTO} loginUserDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public logIn(loginUserDTO: LoginUserDTO, options?: any) {
    return DefaultApiFp(this.configuration)
      .logIn(loginUserDTO, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {UserDTO} userDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public logOut(userDTO: UserDTO, options?: any) {
    return DefaultApiFp(this.configuration)
      .logOut(userDTO, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {Array<string>} requestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public markMessageAsSeen(requestBody: Array<string>, options?: any) {
    return DefaultApiFp(this.configuration)
      .markMessageAsSeen(requestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {NotificationDTO} notificationDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public markNotifcationAsRead(
    notificationDTO: NotificationDTO,
    options?: any
  ) {
    return DefaultApiFp(this.configuration)
      .markNotifcationAsRead(notificationDTO, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {RefreshTokenDTO} refreshTokenDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public refresh(refreshTokenDTO: RefreshTokenDTO, options?: any) {
    return DefaultApiFp(this.configuration)
      .refresh(refreshTokenDTO, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {RegisterUserDTO} registerUserDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public register(registerUserDTO: RegisterUserDTO, options?: any) {
    return DefaultApiFp(this.configuration)
      .register(registerUserDTO, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {SendMessageDTO} sendMessageDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public sendMessage(sendMessageDTO: SendMessageDTO, options?: any) {
    return DefaultApiFp(this.configuration)
      .sendMessage(sendMessageDTO, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
